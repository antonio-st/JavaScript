## Замена циклов с помощью рекурсии

## Replace Loops using Recursion


> *Рекурсия* — это концепция, согласно которой функция может быть выражена через саму себя. Чтобы лучше понять это, начните с размышлений о следующей задаче: умножьте первые n элементов массива, чтобы получить произведение этих элементов. Используя цикл for, вы можете сделать это:

```
  function multiply(arr, n) {
    let product = 1;
    for (let i = 0; i < n; i++) {
      product *= arr[i];
    }
    return product;
  }
```
Однако обратите внимание, что умножить(обр, n) == умножить(обр, n - 1) * обр[n - 1]. Это означает, что вы можете переписать умножение с точки зрения самого себя и вам никогда не понадобится использовать цикл.
```
 function multiply(arr, n) {
    if (n <= 0) {
      return 1;
    } else {
      return multiply(arr, n - 1) * arr[n - 1];
    }
  }
```
Рекурсивная версия умножения работает следующим образом. В базовом случае, когда n <= 0, он возвращает 1. Для больших значений n он вызывает сам себя, но с n - 1. Этот вызов функции оценивается таким же образом, вызывая умножение снова до тех пор, пока n <= 0. В этот момент все функции могут вернуться, и исходное умножение возвращает ответ.

Примечание. Рекурсивные функции должны иметь базовый случай, когда они возвращаются без повторного вызова функции (в этом примере, когда n <= 0), иначе они никогда не смогут завершить выполнение.

---
Напишите рекурсивную функцию sum(arr, n), которая возвращает сумму первых n элементов массива arr.